#+title: Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle "init.el"

* Introduction
This is my emacs configuration at the limit of N\to\infty, where N is the number of iterations that the config has suffered. Since the condition for the thermodynamic limit has been satisfied, this config behaves the way I want. At least for most of the things I want. For the people not familiar with the thermodynamic limit, I will try to explain in a couple of sentences. Imagine a bottle filled with air. When the number of air molecules in the bottle is large enough, what an individual molecule do doesn't matter, but emergent quantities like density and pressure determine the dynamics. An analogy drawn to the config would be how the config collectively behaves versus each code block blocking the other functions.
The blogs and tutorials that have been helpful are the following.  

1. [[https://systemcrafters.net/emacs-from-scratch/] Systems Crafters Emacs from scratch]
2. [[https://hieuphay.com/doom-emacs-config/] My emacs config by Hieu Phay] and possibly also vanilla emacs config [[https://hieuphay.com/emacs-config/]]
3. [https://michaelneuper.com/posts/efficient-latex-editing-with-emacs] Introduction to latex editing by Micheal Neuper]
4. https://github.com/daviwil/emacs-from-scratch/blob/master/Emacs.org Notes on the config. Could be important.
 
The following are blogs are also recommended, as it pop-ups frequently when searching for other people configs.  Although I have never read these blogs to put firm weight on the recommendation.

1. [[https://sachachua.com/dotemacs/index.html#babel-init] Sacha Chua emacs config]
2. Mastering Emacs [[https://www.masteringemacs.org/book]] 
 
** Emacs as a whole
The title makes a very little sense, I will rant about my thoughts on emacs for a while. A little background is necessary. Computer was never a part of my work life until I started my Master's degree. Even then the use case was limited to writing basic fortran programs in a shared machine. The real machine I had was when I quit the Master's degree and joined an Integrated MS-PhD program. It was quite late for a machine at this age (around 2014). Also, the etiquette to maintain a good habit of taking notes, organizing them into publishable articles, writing good codes e.t.c was missing. I am blaming it to not having a computer, but having a good environment enabling people to do these things also matter. 

Having a personal machine changed a few things. Social media provied the environment, as I was able to read on how people organize life. As time went by I was needed to write both programs and codes a lot. And then came the configuration blackhole of Emacs. Historically speaking the software itself was written in 70s. Its age is comparable to lifetime of a person for instance. It is amazing to think on how a software this old has survived to date and is actively maintained. There are many libraries which are also old, but software packages are few. 

Since emacs is very old, it is like old-grandpa/mom (can't think of any gender-neutral term here). Like grandpa has done a lot in his life, a lot of things have been done in emacs. Thus, there are thousands/millions of functions that are build in it. It gets difficult to browse through them to know what each of these do. (Can't organize my thoughts at this moment will revisit later) One key aspect of elisp is that although it is fun, of which some needs to be called in certain sequence to acheive what you desire with the Emacs.  There are simply too many of them and at this point of time no one would be able to provide an appropriate answer. Another aspect that I think has emerged is that there are many function api's which perform similarly differing only very slightly. Come up with some example here.

** Not working or needs improvements
The following are the configs I would want to implement at some level to enhance my work flow
1. Organize the config into sub parts to ensure that each source blocks has only about 60?70 lines of config. It should be such that each block fits into the screen perfectly.
2. Table in org-mode with +----+---+ is bit weird
3. Corfu not working with yas. Fix it.
4. pdf-tools scroll is not very smooth
5. Configure Magit and fly-check
6. EMMS set up a local music directory with few music
   
   
* Important definitions

| SYMBOLS | DEFINITION             | DESCRIPTION                                      |
| M-x     | Yas-describe-table     | loads all the snippets for the current mode      |
| M-x     | customize-variable     | will allow customization of any variables.       |
| M-x     | describe-function      | will describe the desired function               |
| C-c n l | org-roam-buffer-toggle | toggle between different org-roam buffers        |
| C-c n f | org-roam-node-find     | Find a node in org roam file with specific title |
| C-c n i | org-roam-node-insert   | Insert a title with a org-roam node              |
| C-M-i   | completion-at-point    | Complete at a point in a emacs traditional way   |
| M-i     | tab-to-tab-stop        | Inserts tab                                      |
| C-\     | toggle-input-method    | Useful to insert greek symbols in julia block    |
|         |                        |                                                  |

In zathura synctex use control and mouse button 1 to go to the text buffer opened in emacs.


* General
The general setting for the username, font and have the scratch buffer as the start etc.  
** Server
This command should come at the very beginning. The purpose is to start a server with which several files can be opened in an existing emacs software. Just type emacsclient <filename> anywhere in the terminal, it will open in an existing emacs window, provided it is running in the background. 

#+begin_src emacs-lisp :tangle "init.el"
(server-start)
#+end_src

** Username and font
The font I the have converged on are following
*Fixed-space* where the each letter are spaced equally aka monospaced
1. Fira-Mono/Code (Code variants comes with ligatures which eventually becomes difficult to edit.)
2. Source-Code Pro
3. Mononoki 
4. IBM-PLEX-MONO
5. Iosevka
*Variable Pitch* letters are not fixed pitched
1. Fira-Sans-Book 
2. IBM-Sans ; Source-Code-Sans;  Source-SansV15
3. Cartilla
4. TeX Gyre Pagella/Iosevka Etiole  for a book like feel
5. Iosevka Nerd Font (Maybe this has fixed pitch) Iosevka Etoile
6. Cardo google font. The famous book Mastering Emacs  uses this font. 
Important hack to remember here is that all of the above font can be build in Iosevka. This has already been done and are present in the arch package manager as ttc-iosevka-ss<xx> xx is number corresponding to some build close to above mentioned font.
#+begin_src emacs-lisp :tangle "init.el" 

;username
  (setq user-full-name "Vikash"
        user-mail-address "vkpnbeta@gmail.com")

(add-to-list 'exec-path "/home/vikash/opt/anaconda3/bin")
(add-to-list 'exec-path "/home/vikash/opt/julia-1.10.0/bin")
; julia path
(setenv "PATH" (concat (getenv "PATH") ":" (expand-file-name "/home/vikash/opt/julia-1.10.0/bin")))
(setenv "PATH" (concat (expand-file-name "/home/vikash/opt/anaconda3/bin") ":" (getenv "PATH")))

;set the font
(set-face-attribute 'default nil :font "Iosevka Custom" :height 150 :weight 'Semibold)
(set-face-attribute 'fixed-pitch nil :font "Iosevka Custom" :height 150 :weight 'Semibold)
;; (set-face-attribute 'variable-pitch nil :font "SourceSans3VF" :height 155 :weight 'Regular)
(set-face-attribute 'variable-pitch nil :font "CMU Typewriter Text" :height 170 :weight 'Regular)
;;(set-face-attribute 'variable-pitch nil :font "Iosevka Etoile" :height 145 :weight 'Regular)
;; (set-face-attribute 'variable-pitch nil :font "CMU Concrete" :height 135 :weight 'SemiBold)

#+end_src

#+RESULTS:
** The looks of buffer
The codes below customizes the buffer. I think the commands are self-explainatory.

#+begin_src emacs-lisp

(setq make-backup-files nil
      auto-save-default nil) ; to prevent emacs from creating files with ~ in the end. 
(setq inhibit-startup-message t) ; Disable startup message
(switch-to-buffer "*scratch*")   ; Switch to *scratch* buffer on startup
(setq initial-scratch-message "
; #+PROPERTY: header-args:jupyter-julia  :session ~/.kernel/emacs-julia-1.10-kernel.json
; #+PROPERTY: header-args:jupyter-julia  :session /ssh:vikash<hostname>:~/.kernel/emacs-julia-1.10-kernel.json
"); Although these are set in yasnippet I want it in here so that it can be pasted quickly in the org-mode
(setq use-dialog-box nil) 
(defalias 'yes-or-no-p 'y-or-n-p) ; no need to type yes and no in emacs
(display-time) ; display time in the modebar
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(show-paren-mode 1)
(electric-pair-mode t) ; always make two brackets or quotes 
(save-place-mode t)
(savehist-mode t)
(recentf-mode t)
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
;; (setq indent-line-function 'insert-tab)
(setq ring-bell-function 'ignore)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
;; These are for the transparancy
(set-frame-parameter nil 'alpha-background 100) ; For current frame
(add-to-list 'default-frame-alist '(alpha-background . 100))

#+end_src


* Straight
Straight is a package manager which downloads package from the git. I also load the org immediately because the org version error that appears constantly whenever I call any org functions.

#+begin_src emacs-lisp :tangle "init.el" 
        
(defvar bootstrap-version)
(let ((bootstrap-file
      (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
        "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
        'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)

#+end_src

** Install org-mode
Seems this is a dependency from emacs-jupyter package which installs org from the package manager. I would have liked to have jupyter rely on the org that comes default with the emacs installation. Since this is not the case I will have to install it. 
#+begin_src emacs-lisp :tangle "init.el"

(use-package org
  :straight t
  :ensure t)

#+end_src
            

* Numbers and dired
Numbers are by default not highlited in emacs. In program mode I like to have the numbers colored differently for more visibility. This is done using highlight-numbers package. Similarly unicode-fonts and nerd-fonts are used to present folders and other things as an icon in dired (directory-mode or buffers). These are simply for the asthetic part of the emacs and serves no purpose in production part. Although it is nice to have a well designed interface if I am spending a lot of time in a day just staring at it. At the end of source block are custom faces which sets the color of the numbers. In addition other org-mode configs are also here. The emacs does it automatically, hence I have kept it all here as I call highlight number the first time.

#+begin_src emacs-lisp :tangle "init.el"

(use-package highlight-numbers
  :straight t
  :ensure t)

(add-hook 'prog-mode-hook #'highlight-numbers-mode)

(use-package unicode-fonts
  :straight t
  :config 
  (unicode-fonts-setup))

(use-package nerd-icons
  :straight t
  ;; :custom
  ;; "Symbols Nerd Font Mono" is the default and is recommended but you can use any other Nerd Font if you want
  ;; (nerd-icons-font-family "Symbols Nerd Font Mono")
  )

(use-package dired-sidebar
  ;; This gives the option to have a nice sidebar with all the dired options.
  :ensure t
  :straight t
  :commands (dired-sidebar-toggle-sidebar))

 (setq dired-sidebar-subtree-line-prefix "__")
 (setq dired-sidebar-use-term-integration t)

(use-package nerd-icons-dired
  :straight t
  :hook
  (dired-mode . nerd-icons-dired-mode))

(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(highlight-numbers-number ((t (:aquamarineforeground "BlueViolet"))))  
 '(org-block ((t (:background "#F8F8FF" :extend t)))) ;; These are for light theme
 '(org-block-begin-line ((t (:foreground "gray1" :background "#EDEADE" :extend t)))) ; light theme
 '(org-block-end-line ((t (:foreground "gray1" :background "#EDEADE" :extend t)))) ; light theme
;  '(org-block ((t (:background "gray10" :extend t)))) ;For dark theme
 ;; '(org-block-begin-line ((t (:foreground "gray60" :background "#595959" :extend t)))) ;For dark  theme
 ;; '(org-block-end-line ((t (:foreground "gray60" :background "#595959" :extend t)))) ; for dark theme
 '(org-level-1 ((t (:foreground "DarkRed" :extend t)))) ; use VoiletRed1 in modus-vivendi
 '(org-level-2 ((t (:foreground "DarkRed" :extend t))))
 '(org-level-3 ((t (:foreground "DarkRed" :extend t))))
 '(org-level-4 ((t (:foreground "DarkRed" :extend t))))
 '(org-level-5 ((t (:foreground "DarkRed" :extend t))))
)
  
#+end_src

#+RESULTS:


* Evil
Evil is the vim-like keybindings in emacs. It is so good that I have never felt the transition process. Doom emacs implements it even better. Here I have evil everywhere as long as I am programming. I don't have evil-mode activated in org-agenda.    
** Load the evil and other subsidiary.
#+begin_src emacs-lisp :tangle "init.el"
  
  (use-package evil
      :straight t
    :ensure t
    :init
    (setq evil-want-integration t) ;; This is optional since it's already set to t by default.
    (setq evil-want-keybinding nil)
    :config
    (evil-mode 1))
 
    (use-package evil-collection
      :straight t
      :ensure t
      :after evil
      :config
     ; (evil-want-keybinding nil)
      (evil-collection-init))

    (use-package evil-escape
      :straight t
      :ensure t
      :config
      (evil-escape-mode 1)
      (setq-default evil-escape-key-sequence "fd"))

#+end_src

** Evil packages 
These are packages even in vim. It is great that it is implemented in Emacs as well.

#+begin_src emacs-lisp :tangle "init.el"

    (use-package evil-surround
      :straight t
      :ensure t
      :config
      (global-evil-surround-mode 1))

    (use-package evil-commentary
      :straight t
      :ensure t
      :config
      (evil-commentary-mode))

  (use-package evil-org
      :straight t
      :ensure t
      :config
      (add-hook 'org-mode-hook 'evil-org-mode))

;(define-key evil-normal-state-map (kbd "gj") 'evil-next-visual-line)
;;(define-key evil-insert-state-map (kbd "<tab>") 'tab-to-tab-stop)

(define-key evil-motion-state-map [remap evil-next-line] #'evil-next-visual-line)
(define-key evil-motion-state-map [remap evil-previous-line] #'evil-previous-visual-line)

                    

#+end_src



* Theme
I will rant for a while. 
Finally settled with the vanilla emacs color scheme with some modification to the org-mode source block. Had to add a shade for org-source blocks.

#+begin_src emacs-lisp :tangle "init.el"

(use-package doom-themes
  :straight t
  )
(use-package spacemacs-theme
  :straight t
  )

(load-theme 'modus-operandi t) 
;; (load-theme 'modus-vivendi t) 
;; (load-theme 'doom-gruvbox-light t) 
;;(load-theme 'spacemacs-light t)
(use-package doom-modeline
  :ensure t
  :straight t
  :hook (after-init . doom-modeline-mode))
(setq doom-modeline-height 20)
;; this is not a theme but colors the braces for better visibility
(use-package rainbow-delimiters
  :straight t
  :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

#+RESULTS:
| rainbow-delimiters-mode | highlight-numbers-mode | display-line-numbers-mode |


* Completions
** Minibuffer completion
Use the ivy with fuzzy finding for the minibuffer. Setting initial-inputs 

#+begin_src emacs-lisp :tangle "init.el"
(use-package flx
      :straight t
      :ensure t)

  (use-package ivy
    :straight t
    :config
      (setq ivy-use-virtual-buffers t
          ivy-count-format "(%d/%d) "
         ;; ivy-initial-inputs-alist nil
         ))

  (use-package counsel
    :straight t
    :ensure t
    :config
    (ivy-mode 1)
    (setq ivy-height 20)
    (setq ivy-re-builders-alist
      '((ivy-switch-buffer . ivy--regex-plus)
        (t . ivy--regex-fuzzy))))



  ;; (setf (alist-get 'counsel-ag ivy-re-builders-alist)
  ;;       #'ivy--regex-fuzzy)

;(global-set-key (kbd "TAB") (lambda () (interactive) (insert-char 32 4)))

(global-set-key (kbd "C-s") 'swiper-isearch)
(global-set-key (kbd "M-x") 'counsel-M-x)
(global-set-key (kbd "M-y") 'counsel-yank-pop)
(global-set-key (kbd "<f1> f") 'counsel-describe-function)
(global-set-key (kbd "<f1> v") 'counsel-describe-variable)
(global-set-key (kbd "<f1> l") 'counsel-find-library)
(global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
(global-set-key (kbd "<f2> u") 'counsel-unicode-char)
(global-set-key (kbd "<f2> j") 'counsel-set-variable)
(global-set-key (kbd "C-x b") 'ivy-switch-buffer)
(global-set-key (kbd "C-c v") 'ivy-push-view)
(global-set-key (kbd "C-c V") 'ivy-pop-view)
  ;This sets ivy--regex-fuzzy as the fuzzy matching strategy for all Ivy completion.
  ;Optionally, you can also enable ivy-mode globally for all buffers. Add the following line to your configuration:

  (use-package ibuffer
    :straight t
     :config
    (evil-set-initial-state 'ibuffer-mode 'normal))

(use-package nerd-icons-ibuffer
  :ensure t
  :straight t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

  (use-package general
    :straight t
    :config
    (general-define-key
      :states '(normal visual insert emacs)
      :prefix "SPC"
      :non-normal-prefix "M-SPC"
      "b i" 'ibuffer
      "f f" 'counsel-find-file
      "m t" 'org-todo
       "n t" 'org-todo-list
  ))


(use-package yasnippet
  :straight t
  :config
  (yas-global-mode))
(define-key yas-minor-mode-map (kbd "TAB") 'yas-expand)
(define-key yas-minor-mode-map (kbd "<tab>") 'yas-expand)


(use-package yasnippet-snippets
  :straight t)

(setq yas-snippet-dirs (append yas-snippet-dirs
                               '("/home/vikash/.emacs.d/snippets")))
(use-package which-key
  :straight t
  :init
  (setq
   which-key-show-early-on-C-h t
   which-key-idle-delay 10000
   which-key-idle-secondary-delay 0.05
  which-key-popup-type 'minibuffer
  which-key-side-window-max-height 0.25)
  :config
  (which-key-mode) 
  )

;; ibuffer-sidebar seems to not work well
(use-package ibuffer-sidebar
  :straight t
  :commands (ibuffer-sidebar-toggle-sidebar)
  )

(defun +sidebar-toggle ()
  "Toggle both `dired-sidebar' and `ibuffer-sidebar'."
  (interactive)
  (dired-sidebar-toggle-sidebar)
  (ibuffer-sidebar-toggle-sidebar))

(use-package ivy-rich
  :straight t
  :init 
 (ivy-rich-mode 1))

(use-package nerd-icons-ivy-rich
  :straight t
  :ensure t
  :init
  (nerd-icons-ivy-rich-mode 1)
  )


#+end_src

#+RESULTS:
: +sidebar-toggle

** Main buffer completion
Use corfu with orderless for the main buffer completion

#+begin_src emacs-lisp :tangle "init.el"
  (use-package company
    :straight t
    :ensure t)

  ;; (add-hook 'org-mode-hook
  ;;           (lambda ()
  ;;             (setq-local company-backends
  ;;                         (cons 'company-capf company-backends))))

  (add-to-list 'company-backends 'company-dabbrev-code) 
  (add-to-list 'company-backends 'company-yasnippet)
  (add-to-list 'company-backends 'company-files)

  ;; somehow corfu doesnot work
  (use-package corfu
    :straight t
    :config
    (global-corfu-mode)
    (setq corfu-cycle t
          corfu-auto t
          corfu-commit-predicate nil
          corfu-quit-at-boundary t
          corfu-quit-no-match 'separator
          corfu-echo-documentation nil))

  (use-package orderless
    :straight t
    :config
    (setq completion-styles '(orderless)
          orderless-component-separator #'orderless-escapable-split-on-space))

  (global-set-key [remap completion-at-point] #'corfu-completion-at-point)
  (global-set-key [remap completion] #'corfu-completion)

  (with-eval-after-load 'corfu
    (setq corfu-auto-delay 0.2
          corfu-auto-prefix-style 'partial
          corfu-commit-delay 0.1
          corfu-echo-documentation nil
          corfu-quit-delay 0.2
          corfu-quick-help-delay 1.0
          corfu-quick-help-height 30))


  ;; Use Dabbrev with Corfu!
  (use-package dabbrev
    :straight t
    ;; Swap M-/ and C-M-/
    :bind (("M-/" . dabbrev-expand)
           ("C-M-/" . dabbrev-completion))
    :config
    (add-to-list 'dabbrev-ignored-buffer-regexps "\\` ")
    ;; Since 29.1, use `dabbrev-ignored-buffer-regexps' on older.
    (add-to-list 'dabbrev-ignored-buffer-modes 'doc-view-mode)
    (add-to-list 'dabbrev-ignored-buffer-modes 'pdf-view-mode))

  ;; Add extensions
  (use-package cape
    :straight t
    ;; Bind dedicated completion commands
    ;; Alternative prefix keys: C-c p, M-p, M-+, ...
    :bind (("C-c p p" . completion-at-point) ;; capf
           ("C-c p t" . complete-tag)        ;; etags
           ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
           ("C-c p h" . cape-history)
           ("C-c p f" . cape-file)
           ("C-c p k" . cape-keyword)
           ("C-c p s" . cape-elisp-symbol)
           ("C-c p e" . cape-elisp-block)
           ("C-c p a" . cape-abbrev)
           ("C-c p l" . cape-line)
           ("C-c p w" . cape-dict)
           ("C-c p \\" . cape-tex)
           ("C-c p _" . cape-tex)
           ("C-c p ^" . cape-tex))
    :init
    ;; Add to the global default value of `completion-at-point-functions' which is
    ;; used by `completion-at-point'.  The order of the functions matters, the
    ;; first function returning a result wins.  Note that the list of buffer-local
    ;; completion functions takes precedence over the global list.
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-elisp-block)
    ;;(add-to-list 'completion-at-point-functions #'cape-history)
    ;;(add-to-list 'completion-at-point-functions #'cape-keyword)
    ;;(add-to-list 'completion-at-point-functions #'cape-tex)
    ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
    ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
    ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
    ;;(add-to-list 'completion-at-point-functions #'cape-dict)
    ;;(add-to-list 'completion-at-point-functions #'cape-elisp-symbol)
    ;;(add-to-list 'completion-at-point-functions #'cape-line)
  )


(use-package yasnippet-capf
  :straight t
  :after cape
  :config
  (add-to-list 'completion-at-point-functions #'yasnippet-capf))
;; It expands automoatically which is annoying
(setopt corfu-on-exact-match 'show)
;; (require 'company-yasnippet)
;; (add-to-list 'completion-at-point-functions
;;                      (cape-company-to-capf #'company-yasnippet))


  (use-package emacs
    :straight t
    :init
    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 3)
    ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
    ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)
    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete))

  (use-package nerd-icons-corfu
    :straight t
    )
(add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter)

  ;; (add-hook 'org-mode-hook 'corfu-mode)

#+end_src

#+RESULTS:


* Org-mode configuration
** General
#+begin_src emacs-lisp :tangle "init.el"


  ;; src block indentation / editing / syntax highlighting
  (setq org-src-fontify-natively t
        org-src-window-setup 'current-window ;; edit in current window
        org-src-strip-leading-and-trailing-blank-lines t
 ;       org-src-tab-acts-natively t
        org-latex-create-formula-image-program 'dvisvgm
        org-src-preserve-indentation t) ;; do not put two spaces on the left

(defun my/org-src-tab-width ()
  "Set tab width to 4 spaces in Org source blocks."
  (setq-local tab-width 4)
  (setq-local indent-tabs-mode nil))

;; Disable line number mode in several buffers;
(dolist (mode '(org-mode-hook
                term-mode-hook
                shell-mode-hook
                treemacs-mode-hook
                eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))


;(add-hook 'org-mode-hook
;          (lambda ()
;            (add-hook 'org-src-mode-hook 'my/org-src-tab-width)))

(defun my/org-src-tab-insert ()
  "Insert 4 spaces instead of a tab in Org source blocks."
  (interactive)
  (if (org-in-src-block-p)
      (insert "   ")
    (call-interactively 'indent-for-tab-command)))

; (define-key org-src-mode-map (kbd "TAB") 'my/org-src-tab-insert)

(setq org-ellipsis " ····")
#+end_src

#+RESULTS:
: my/org-src-tab-insert

** Font and feel for the org-mode buffers
First we set visual look and later we set the bullets.
*** Fill the column for nicer look
Here we set the visual fill column mode for the nice feel it provides. 

#+begin_src emacs-lisp :tangle init.el
(use-package visual-fill-column
  :ensure t
  :commands visual-fill-column-mode)

(setq visual-fill-column-width 140
      visual-fill-column-center-text t)

(defun org-mode-setup ()
  (org-indent-mode)
  (variable-pitch-mode 1)
  (visual-line-mode 1))

(add-hook 'org-mode-hook 'visual-fill-column-mode)
(add-hook 'ibuffer-mode-hook 'visual-fill-column-mode)
(add-hook 'org-mode-hook 'org-mode-setup)

#+end_src

*** Font config

#+begin_src emacs-lisp :tangle init.el

    ;; (custom-set-faces
    ;; '(variable-pitch ((t (:family "CMU Sans Serif" :height 150)))))
(add-hook 'org-mode-hook 'variable-pitch-mode) 

  (defun org-font-setup ()
    ;; Replace list hyphen with dot
   (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    ;; Set faces for heading levels
    (dolist (face '((org-level-1 . 1.40)
                    (org-level-2 . 1.30)
                    (org-level-3 . 1.2)
                    (org-level-4 . 1.1)
                    (org-level-5 . 1.05)
                    (org-level-6 . 1.05)
                    (org-level-7 . 1.05)
                    (org-level-8 . 1.05)))
      (set-face-attribute (car face) nil :font "CMU Typewriter Text" :weight 'Bold :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-document-info-keyword nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-property-value nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-tag nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-block-begin-line nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-block-end-line nil :inherit 'fixed-pitch)
    )
(org-font-setup)

#+end_src

#+RESULTS:

*** Org mode bullets
Here we set the bullets to make the headings clear

#+begin_src emacs-lisp :tangle init.el

(use-package org-bullets
  :straight t
  :ensure t
  :after org
  :hook (org-mode . org-bullets-mode)
  :config
  (setq org-bullets-bullet-list '("➜" "⤷" "⤷" "⤷" "⤷")))

;➀➁➂➃➄➅➆➇➈➉
;➜	
;✰✱✲✳✴✵✶✷✸✹✺	
;➥	
;⟾	
;⤿
;⟹🢂	
#+end_src

*** Set up the template
Set the template for setting the

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load 'org
  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  (add-to-list 'org-structure-template-alist '("jp" . "src jupyter-python"))
  (add-to-list 'org-structure-template-alist '("jj" . "src jupyter-julia"))
)

#+end_src

** Babel configuration

#+begin_src emacs-lisp :tangle "init.el"

(use-package gnuplot
  :straight t
  )

;; (use-package ob-async
;;   :straight t)

;; (use-package ob-ipython
;;   :straight t
;;   )

(use-package jupyter
  :straight t
  )


(use-package ess
:straight t
)

(use-package julia-mode
:straight t
)

(use-package julia-vterm
:straight t
)

  ; to prevent the funny indentation.

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (python . t)
       (jupyter . t)
       (shell . t)
       (latex . t)
       (dot . t)
       (gnuplot . t)
       (julia . t)
       )
     )

 (with-eval-after-load 'jupyter 
    (define-key jupyter-repl-mode-map (kbd "C-l") #'jupyter-repl-clear-cells)
    (define-key jupyter-repl-mode-map (kbd "TAB") #'company-complete-common-or-cycle)
   ; (define-key jupyter-org-interaction-mode-map (kbd "TAB") #'company-complete-common-or-cycle)
    (define-key jupyter-repl-interaction-mode-map (kbd "C-c C-r") #'jupyter-eval-line-or-region)
    (define-key jupyter-repl-interaction-mode-map (kbd "C-c M-r") #'jupyter-repl-restart-kernel)
    (define-key jupyter-repl-interaction-mode-map (kbd "C-c M-k") #'jupyter-shutdown-kernel)
   ; (add-hook 'jupyter-org-interaction-mode-hook (lambda ()  (company-mode)
   ;						   (setq company-backends '((company-capf))))) 
  ;  (add-hook 'jupyter-repl-mode-hook (lambda () (company-mode)
				;        :config (set-face-attribute
					;         'jupyter-repl-input-prompt nil :foreground "dim gray")
				       ; :config (set-face-attribute
					;         'jupyter-repl-input-prompt nil :background "lightblue")
				        ;; :config (set-face-attribute 'comment
				        ;; 			    nil :foreground "dim gray")
				        ;:config (set-face-attribute
					;         'jupyter-repl-output-prompt nil :foreground "black")
;				        (setq company-backends '((company-capf)))))
    ;; (add-hook 'jupyter-repl-mode-hook #'smartparens-mode)
    ;; (setq jupyter-repl-prompt-margin-width 4)
    )


(add-to-list 'org-src-lang-modes '("jupyter-julia" . julia))
(add-to-list 'org-src-lang-modes '("jupyter-python" . python))

(defalias 'org-babel-variable-assignments:jupyter-julia 'org-babel-variable-assignments:julia)
(add-hook 'julia-mode-hook #'julia-vterm-mode)
;; (setq org-ditaa-jar-path "/usr/share/java/ditaa/ditaa-0.11.jar")
(push '("conf-unix" . conf-unix) org-src-lang-modes)
(setq org-confirm-babel-evaluate nil)
;; Syntax highlight in #+BEGIN_SRC blocks
(setq org-src-fontify-natively t)

(add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
;(add-hook org-babel-after-execute-hook 'org-display-inline-images 'append)

#+end_src

#+RESULTS:
| org-redisplay-inline-images |

** Org-agenda for organizing my calender
Org-agenda is an old way to track journals set up meetings etc. With different calanders that do it automatically this program will not that useful now I guess. I want it do just track basic todos and any travel plans I have. 

*** Keybindings
Coming from the vim mode I keep pressing j and k in the org-agenda mode. These are bound to go-to-date-time and capture template respectively. Since I don't need to use these, best I unbind them and leave these function unassigned. I want my agenda to load very fast. hence F7 

#+begin_src emacs-lisp :tangle init.el

(global-set-key (kbd "<f7>") 'org-agenda)

(eval-after-load 'org-agenda
  '(progn
     (define-key org-agenda-mode-map "j" nil)
     (define-key org-agenda-mode-map "k" nil)))                                       ;

#+end_src

*** Basic settings
Here I set the basics of agenda and set files from which to read the entries for dashboard. It expects Tasks and Meetings and Planning  
#+begin_src emacs-lisp :tangle init.el

 (setq     org-agenda-start-with-log-mode t
      org-log-done 'time
      org-log-into-drawer t
      org-agenda-span 8
      org-agenda-start-on-weekday nil
      org-agenda-start-day "-3d"
      org-agenda-files
      '("~/Documents/OrgFiles/Tasksandmeetings.org"  ;; Tasksandmeeting.org
        "~/Documents/OrgFiles/Planning.org" ;; Planning.org
        "~/Documents/OrgFiles/Birthdays.org") ;; Birthdays.org
      org-todo-keywords
      '((sequence "TODO(t)" "STARTED" "|" "DONE(d)" "CANC(c)")
       (sequence "PLAN(p)" "REMINDER(r)" "WAIT(w@/!)" "|" "COMPLETED(c)" "CANCELLED(k@)" ))
      )


(setq org-refile-targets
      '(("~/Documents/Orgfiles/Archive.org" :maxlevel . 1)))

;; Save Org buffers after refiling!
(advice-add 'org-refile :after 'org-save-all-org-buffers)

#+end_src

#+RESULTS:

*** Dashboard 
 This is the main deal. Here I will design what I want to appear in the dashboard.

#+begin_src emacs-lisp :tangle init.el

(setq org-agenda-custom-commands
      '(("d" "Dashboard"
         ((agenda "" ((org-deadline-warning-days 7)))
          (todo "PLAN"
                ((org-agenda-overriding-header "planning")))
           (todo "TODO"
                ((org-agenda-overriding-header "todos")))
          (todo "REMINDER"
                ((org-agenda-overriding-header "Reminders")))))))



#+end_src


*** Capture the template
#+begin_src emacs-lisp :tangle init.el

(setq org-capture-templates
      `(("t" "Tasks / Projects")
        ("tt" "Task" entry (file+olp "~/Documents/OrgFiles/Tasksandmeetings.org" "Meetings")
         "** TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)
        ("p" "plan / Reminder")
        ("pp" "Plan" entry (file+olp "~/Documents/OrgFiles/Planning.org" "Future Plans")
         "** PLAN %?\n  %U\n  %a\n  %i" :empty-lines 1)
        ("j" "Journal Entries")
        ("jj" "Journal" entry
         (file+olp+datetree "~/Documents/OrgFiles/Journal.org")
         "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
         :clock-in :clock-resume
         :empty-lines 1)
        ))

(define-key global-map (kbd "C-c j")
  (lambda () (interactive) (org-capture nil "jj")))

(define-key global-map (kbd "C-c p")
  (lambda () (interactive) (org-capture nil "pp")))

(define-key global-map (kbd "C-c t")
  (lambda () (interactive) (org-capture nil "tt")))

#+end_src

#+RESULTS:
| lambda | nil | (interactive) | (org-capture nil tt) |

** Org-Roam
Org roam is a new note-keeping tools in emacs and integrates well with org. I don't use org-mode a lot; but since I am unable to escape the note keeping part and a lot of documents I read tends to get lost over time leading to an infinite loop of doing the same thing again and again. I will start organizing my notes using org-roam from now on. The below configuration is copy pasted from
 davil emacs-from scratch series.
 
#+begin_src  emacs-lisp

(use-package org-roam
  :ensure t
  :straight t
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory "~/Documents/my_notes/RoamNotes")
  (org-roam-completion-everywhere t)
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)
         :map org-mode-map
         ("C-M-i"    . completion-at-point))
  :config
  (org-roam-setup))

  (use-package citar-org-roam
  :straight t
  :after (citar org-roam)
  :config (citar-org-roam-mode))
#+end_src

#+RESULTS:
: completion-at-point


* Eglot and treesitter

** Eglot

#+begin_src emacs-lisp :tangle init.el

 (use-package project :straight t) ;; Somehow the project is removed 

  (use-package eglot
    :straight t
;    :hook
     ;; (c-mode-hook . eglot-ensure)
     ;; (f90-mode-hook . eglot-ensure)
    )

(with-eval-after-load 'eglot
   (setq completion-category-defaults nil))

(advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)

#+end_src

#+RESULTS:

** tree-sitter

Tree sitter is a new way of highlighting

#+begin_src emacs-lisp :tangle init.el

    (use-package tree-sitter
      :straight t
      :init
       (global-tree-sitter-mode))

    (use-package tree-sitter-langs
      :straight t
    )
  ;; (add-hook 'python-mode-hook #'tree-sitter-mode)

(setq treesit-language-source-alist
      '(
     (bash "https://github.com/tree-sitter/tree-sitter-bash")
     (cmake "https://github.com/uyha/tree-sitter-cmake")
     (elisp "https://github.com/Wilfred/tree-sitter-elisp")
     (json "https://github.com/tree-sitter/tree-sitter-json")
     (make "https://github.com/alemuller/tree-sitter-make")
     (markdown "https://github.com/ikatyang/tree-sitter-markdown")
     (python "https://github.com/tree-sitter/tree-sitter-python")
     (yaml "https://github.com/ikatyang/tree-sitter-yaml")
     (fortran  "https://github.com/stadelmanma/tree-sitter-fortran")
     (c "https://github.com/tree-sitter/tree-sitter-c")
     (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
     (cuda "https://github.com/theHamsta/tree-sitter-cuda")
     (julia "https://github.com/tree-sitter/tree-sitter-julia")
     (latex "https://github.com/latex-lsp/tree-sitter-latex")
     (org"https://github.com/milisims/tree-sitter-org")
   ))

#+end_src

#+RESULTS:
| bash     | https://github.com/tree-sitter/tree-sitter-bash    |
| cmake    | https://github.com/uyha/tree-sitter-cmake          |
| elisp    | https://github.com/Wilfred/tree-sitter-elisp       |
| json     | https://github.com/tree-sitter/tree-sitter-json    |
| make     | https://github.com/alemuller/tree-sitter-make      |
| markdown | https://github.com/ikatyang/tree-sitter-markdown   |
| python   | https://github.com/tree-sitter/tree-sitter-python  |
| yaml     | https://github.com/ikatyang/tree-sitter-yaml       |
| fortran  | https://github.com/stadelmanma/tree-sitter-fortran |
| c        | https://github.com/tree-sitter/tree-sitter-c       |
| cpp      | https://github.com/tree-sitter/tree-sitter-cpp     |
| cuda     | https://github.com/theHamsta/tree-sitter-cuda      |
| julia    | https://github.com/tree-sitter/tree-sitter-julia   |
| latex    | https://github.com/latex-lsp/tree-sitter-latex     |
| org      | https://github.com/milisims/tree-sitter-org        |


* Latex
** Font 
The font in the latex is set to Typewriter text from CMU. 
#+begin_src emacs-lisp :tangle init.el
 (defun my/set-latex-font ()
  "Set a different font for LaTeX files."
  (face-remap-add-relative 'default :family "CMU Typewriter Text" :height 170))

(add-hook 'LaTeX-mode-hook 'my/set-latex-font)
 
#+end_src

#+RESULTS:
| my/set-latex-font | preview-mode-setup | citar-capf-setup | my/latex-hooks | TeX-source-correlate-mode |

** General latex configuration

#+begin_src emacs-lisp :tangle init.el

;; latex config 
;; this is for reading pdf in emacs;
(use-package pdf-tools
  :straight t)
(pdf-tools-install)

(defun my/hooks_pdf_tools ()
  "Disable line numbers in the current buffer."
  (display-line-numbers-mode -1)
  (auto-revert-mode 1)
)

(add-hook 'pdf-view-mode-hook 'my/hooks_pdf_tools)

(use-package auctex
  :straight t
  )

(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq-default TeX-master 'nil)

(use-package xenops
  :straight t )
;;   ;:config
;; (add-hook LaTeX-mode-hook xenops-mode)
;; (add-hook LaTeX-mode-hook #'xenops-mode))

;; Add this to .emacs.d/init.el:
(with-eval-after-load "tex"
  ;; enable synctex support for latex-mode
  (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
  ;; add a new view program
  (add-to-list 'TeX-view-program-list
        '("Zathura"
          ("zathura" " %o"
           (mode-io-correlate " --synctex-forward %n:0:%b"))))
  (setcdr (assq 'output-pdf TeX-view-program-selection) '("Zathura")))



(setq xenops-reveal-on-entry t
      xenops-image-directory (expand-file-name "xenops/image" user-emacs-directory)
      xenops-math-latex-process 'dvisvgm
      xenops-math-image-scale-factor 0.7
      )

(defun xenops-math-reveal (element)
  "Remove image overlay for ELEMENT.
If a prefix argument is in effect, also delete its cache file."
  (xenops-element-overlays-delete element)
  (if current-prefix-arg
      (delete-file (xenops-math-get-cache-file element)))
  ;; TODO: is :begin-content for block math off by one?
  (let ((element-type (plist-get element :type))
        (begin-content (plist-get element :begin-content)))
    )
  (xenops-math-render-below-maybe element))

(use-package cdlatex
:straight t
)
(defun my/latex-hooks ()
 (turn-on-cdlatex)
 (visual-line-mode t)
 (visual-fill-column-mode t)
)

(add-hook 'LaTeX-mode-hook 'my/latex-hooks)
(add-hook 'latex-mode-hook 'my/latex-hooks)

(add-hook 'pdf-view-mode 'pdf-view-themed-minor-mode)   ; normal emacs latex mode
(set-default 'preview-scale-function 1.1)

(defvar pdf-minimal-width 72
  "Minimal width of a window displaying a pdf.
If an integer, number of columns.  If a float, fraction of the
original window.")

(defvar pdf-split-width-threshold 120
  "Minimum width a window should have to split it horizontally
for displaying a pdf in the right.")

#+end_src

** Biblatex and cite configuration

#+begin_src emacs-lisp

(use-package citar
  :straight t
  :hook
  (LaTeX-mode . citar-capf-setup)
  (org-mode . citar-capf-setup)
  :custom
  (citar-bibliography '("/home/vikash/Documents/my_notes/bib/references.bib")))

(add-to-list 'completion-at-point-functions #'citar-capf)
(setq citar-search-function #'citar-ivy-filter)

(use-package bibtex
  :straight t
  :custom
  (bibtex-dialect 'BibTeX)
  (bibtex-user-optional-fields
   '(("keywords" "Keywords to describe the entry" "")
     ("file" "Link to a document file." "" )))
  (bibtex-align-at-equal-sign t))

(use-package citar-embark
  :straight t
  :after citar embark
  :no-require
  :config (citar-embark-mode))

(use-package biblio
  :straight t)

#+end_src

#+RESULTS:


* Spell and Grammar Check

** Flyspell
For spell checking the go-to tool in emacs is flycheck. The configuration given in the emacs wiki seems sound. I will just copy paste them here.

#+begin_src emacs-lisp

; Seems like flyspell is already installed in emacs; just set it up
  (dolist (hook '(text-mode-hook))
  (add-hook hook (lambda () (flyspell-mode 1))))
(dolist (hook '(change-log-mode-hook log-edit-mode-hook))
  (add-hook hook (lambda () (flyspell-mode -1))))

;; (global-set-key (kbd "<f8>") 'ispell-word)
;; to note vim key-binding z= also works for ispell=word checking
(global-set-key (kbd "C-S-<f8>") 'flyspell-mode)
(global-set-key (kbd "C-M-<f8>") 'flyspell-buffer)
(global-set-key (kbd "C-<f8>") 'flyspell-check-previous-highlighted-word)
(defun flyspell-check-next-highlighted-word ()
  "Custom function to spell check next highlighted word"
  (interactive)
  (flyspell-goto-next-error)
  (ispell-word)
  )
(global-set-key (kbd "M-<f8>") 'flyspell-check-next-highlighted-word) 

#+end_src

#+RESULTS:

** Language server
An alternative tool to keep track of is flycheck-languagetool. This setup will have the options 'M-x langtoo-? to pass the entire text.
#+begin_src emacs-lisp

(use-package langtool
  :straight t)
(setq langtool-java-classpath
      "/usr/share/languagetool:/usr/share/java/languagetool/*")

#+end_src


* Magit
Magit is a emacs package to use git in the buffer. 

#+begin_src emacs-lisp
 (use-package magit
  :straight t
  :commands magit-status
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

;; NOTE: Make sure to configure a GitHub token before using this package!
;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
(use-package forge
  :straight t
  :after magit) 


#+end_src

#+RESULTS:


* Ellama 
This is for interacting with the local AI from emacs.

#+begin_src emacs-lisp
(use-package ellama
  :straight t
  :ensure t
  :bind ("C-c e" . ellama-transient-main-menu)
  ;; send last message in chat buffer with C-c C-c
  :hook (org-ctrl-c-ctrl-c-final . ellama-chat-send-last-message)
  :init (setopt ellama-auto-scroll t)
  :config
  ;; show ellama context in header line in all buffers
  (ellama-context-header-line-global-mode +1))

#+end_src

* Other subsidiaries 
** Markdown-modes
#+begin_src emacs-lisp
  (use-package markdown-mode
  :ensure t
  :straight t
  :mode ("README\\.md\\'" . gfm-mode)
  :init (setq markdown-command "multimarkdown")
  :bind (:map markdown-mode-map
         ("C-c C-e" . markdown-do)))
(use-package yaml-mode
:ensure t
:straight t)
#+end_src

#+RESULTS:

** Emms- emacs native music player
#+begin_src emacs-lisp

  (use-package emms
    :straight t
    :init
    (require 'emms-setup)
    (require 'emms-mpris)
    (emms-all)
    (emms-default-players)
    (emms-mpris-enable)
    :hook
    (emms-browser-mode . visual-fill-column-mode)
    :custom
    (emms-source-file-default-directory "~/Music")
    (emms-browser-covers #'emms-browser-cache-thumbnail-async)
    :bind
    (("<f5>"   . emms-browser)
     ("M-<f5>" . emms)
     ("M-p" . emms-previous)
     ("M-n" . emms-next)
     ("M-s" . emms-pause)))

(emms-all)
(setq emms-player-list '(emms-player-mpv)
      emms-info-functions '(emms-info-native))

#+end_src

#+RESULTS:
| emms-info-native |

** EAF for quick browsing 
This seems to have too much of dependencies. If one breaks everything comes crashing down like cards. Although it is wishful thinking. 
#+begin_src emacs-lisp

(add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework/")
;; (require 'eaf)
;; (require 'eaf-browser)
;; (require 'eaf-pdf-viewer)

#+end_src

#+RESULTS:
: eaf-browser

** Resizing the buffer
#+begin_src emacs-lisp
  
(use-package windresize
  :straight t)

(global-set-key (kbd "<f2>") 'windresize)

#+end_src

#+RESULTS:
: windresize


* Custom 

#+begin_src emacs-lisp
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(TeX-view-program-selection
   '(((output-dvi has-no-display-manager)
      "dvi2tty")
     ((output-dvi style-pstricks)
      "Zathura")
     (output-dvi "Zathura")
     (output-pdf "Zathura")
     (output-html "xdg-open")))
 '(display-time-24hr-format t)
 '(f90-comment-region "!!")
 '(org-agenda-window-setup 'only-window)
 '(org-highlight-latex-and-related '(native))
 '(tex-fontify-script nil)
'(org-startup-folded t))


#+end_src

#+RESULTS:
            



* Might be relevant some-day
These functions will build html from buffer and render.

#+begin_src example
(defun org-babel-render-html ()
  (interactive)
  (let* ((element (org-element-at-point))
         (start (org-element-property :begin element))
         (end (org-element-property :end element))
         (value (org-element-property :value element)))
    (goto-char start)
    (forward-line)
    (delete-region (point) end)
    (insert value)
    (shr-render-region start (point))
    (goto-char start)
    (forward-line)
    (delete-char -1)))

(defun org-babel-process-export-html-block ()
  (interactive)
  (let* ((element (org-element-context))
         (beg (org-element-property :begin element))
         (end (org-element-property :end element))
         (value (org-element-property :value element)))
    (with-temp-buffer
      (insert value)
      (shr-render-buffer (current-buffer)))
    (let ((html-contents (with-current-buffer "*html*"
                           (unless (text-properties-at (point))
                             (let ((contents (buffer-string)))
                               (kill-buffer)
                               contents)))))
      (when (print html-contents)
        (kill-region beg end)
        (goto-char beg)
        (insert "#+RESULTS\n: " html-contents "\n")))))

config for the unicode fonts

(use-package unicode-fonts
  :straight t
  :config
  ;; Common math symbols
  (dolist (unicode-block '("Mathematical Alphanumeric Symbols"))
    (push "JuliaMono" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  (dolist (unicode-block '("Greek and Coptic"))
    (push "Iosevka Custom" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  ;; CJK characters
  (dolist (unicode-block '("CJK Unified Ideographs" "CJK Symbols and Punctuation" "CJK Radicals Supplement" "CJK Compatibility Ideographs"))
    (push "Sarasa Mono SC" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  (dolist (unicode-block '("Hangul Syllables" "Hangul Jamo Extended-A" "Hangul Jamo Extended-B"))
    (push "Sarasa Mono K" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  ;; Other unicode block
  (dolist (unicode-block '("Braille Patterns"))
    (push "Iosevka Custom" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  )

#+end_src example




Initialize thermodynamic rel  








